{
  "p": [
    "Cassandra-5393",
    "Add retry mechanism to OTC for non-droppable_verbs"
  ],
  "(1) Log information": {
    "p": [
      "Setup: three ec2 regions (us-west-2, us-east-1, eu-west-1 - three nodes in each)",
      "When the connection gets dropped, trigger repair on one of the nodes (starting with us-west-2)",
      "Then we can see the eu-west-1 node which got the request to build the merkle tree, but then failed on sending the tree response with the exception below.",
      "INFO [AntiEntropyStage:1] 2013-03-27 22:48:55,390 AntiEntropyService.java (line 239) repair #80fe25a0-9730-11e2-0000-ebe7011631ff Sending completed merkle tree to /54.246.XXX.YYY for (Geo,GeoCountryMetadata)",
      "DEBUG [WRITE-/54.246.XXX.YYY] 2013-03-27 22:48:55,392 OutboundTcpConnection.java (line 165) error writing to ec2-54-246-XXX.YYY.eu-west-1.compute.amazonaws.com/54.246.XXX.YYY",
      "java.net.SocketException: Connection timed out",
      "at java.net.SocketOutputStream.socketWrite0(Native Method)",
      "at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:92)",
      "at java.net.SocketOutputStream.write(SocketOutputStream.java:136)",
      "at com.sun.net.ssl.internal.ssl.OutputRecord.writeBuffer(OutputRecord.java:358)",
      "at com.sun.net.ssl.internal.ssl.OutputRecord.write(OutputRecord.java:346)",
      "at com.sun.net.ssl.internal.ssl.SSLSocketImpl.writeRecordInternal(SSLSocketImpl.java:781)",
      "at com.sun.net.ssl.internal.ssl.SSLSocketImpl.writeRecord(SSLSocketImpl.java:753)",
      "at com.sun.net.ssl.internal.ssl.AppOutputStream.write(AppOutputStream.java:100)",
      "at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)",
      "at java.io.BufferedOutputStream.write(BufferedOutputStream.java:104)",
      "at java.io.DataOutputStream.write(DataOutputStream.java:90)",
      "at java.io.FilterOutputStream.write(FilterOutputStream.java:80)",
      "at org.apache.cassandra.net.OutboundTcpConnection.write(OutboundTcpConnection.java:200)",
      "at org.apache.cassandra.net.OutboundTcpConnection.writeConnected(OutboundTcpConnection.java:152)",
      "at org.apache.cassandra.net.OutboundTcpConnection.run(OutboundTcpConnection.java:126)"
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "This happens in RepairSession, which is implemented in in AntiEntropyService.java.",
      "With the source code, we know that when the node-A sends tree request to node-B, node-A will wait till it receives the tree response, the proceeds, as follows.",
      ""
    ]
  },
  "(3) Root Cause": {
    "p": [
      "The node which sends tree request fails to receive the tree response due to the connection failure, then this node keeps waiting, and the operation hangs."
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the failure. Add a retry mechanism.",
      "The exception is caught when the socket breaks, and the request will be re-sent by requeueing the message at the end of the backlog queue.",
      "â€¢/src/java/org/apache/cassandra/net/OutboundTcpConnection.java",
      "@@ -25,6 +25,7 @@ import java.io.BufferedOutputStream;",
      "import java.io.DataOutputStream;",
      "import java.io.IOException;",
      "import java.net.Socket;",
      "+import java.net.SocketException;",
      "import java.util.concurrent.BlockingQueue;",
      "import java.util.concurrent.LinkedBlockingQueue;",
      "import java.util.concurrent.atomic.AtomicLong;",
      "@@ -72,7 +73,7 @@ public class OutboundTcpConnection extends Thread",
      "expireMessages();",
      "try",
      "{",
      "- backlog.put(new Entry(message, id, System.currentTimeMillis()));",
      "+ backlog.put(new Entry(message, id));",
      "}",
      "catch (InterruptedException e)",
      "{",
      "@@ -127,7 +128,7 @@ public class OutboundTcpConnection extends Thread",
      "if (entry.timestamp < System.currentTimeMillis() - DatabaseDescriptor.getRpcTimeout())",
      "dropped.incrementAndGet();",
      "else if (socket != null || connect())",
      "- writeConnected(m, id);",
      "+ writeConnected(entry, id);",
      "else",
      "// clear out the queue, else gossip messages back up.",
      "active.clear();",
      "@@ -149,8 +150,9 @@ public class OutboundTcpConnection extends Thread",
      "return dropped.get();",
      "}",
      "",
      "- private void writeConnected(Message message, String id)",
      "+ private void writeConnected(Entry entry, String id)",
      "{",
      "+ Message message = entry.message;",
      "try",
      "{",
      "write(message, id, out);",
      "@@ -162,12 +164,32 @@ public class OutboundTcpConnection extends Thread",
      "}",
      "catch (Exception e)",
      "{",
      "- // Non IO exceptions is likely a programming error so let's not silence it",
      "- if (!(e instanceof IOException))",
      "- logger.error(\"error writing to \" + poolReference.endPoint(), e);",
      "- else if (logger.isDebugEnabled())",
      "- logger.debug(\"error writing to \" + poolReference.endPoint(), e);",
      "disconnect();",
      "+",
      "+ if (e instanceof IOException)",
      "+ {",
      "+ if (logger.isDebugEnabled())",
      "+ logger.debug(\"error writing to \" + poolReference.endPoint(), e);",
      "+",
      "+ // if the message was important, such as a repair acknowledgement, put it back on the queue",
      "+ // to retry after re-connecting. See CASSANDRA-5393",
      "+ if (e instanceof SocketException && entry.shouldRetry())",
      "+ {",
      "+ try",
      "+ {",
      "+ backlog.put(new RetriedEntry(entry));",
      "+ }",
      "+ catch (InterruptedException e1)",
      "+ {",
      "+ throw new AssertionError(e1);",
      "+ }",
      "+ }",
      "+ }",
      "+ else",
      "+ {",
      "+ // Non IO exceptions are likely a programming error so let's not silence them",
      "+ logger.error(\"error writing to \" + poolReference.endPoint(), e);",
      "+ }",
      "}",
      "}",
      "",
      "@@ -283,17 +305,36 @@ public class OutboundTcpConnection extends Thread",
      "}",
      "}",
      "",
      "+ /** messages that have not been retried yet */",
      "private static class Entry",
      "{",
      "final Message message;",
      "final String id;",
      "final long timestamp;",
      "",
      "- Entry(Message message, String id, long timestamp)",
      "+ Entry(Message message, String id)",
      "{",
      "this.message = message;",
      "this.id = id;",
      "- this.timestamp = timestamp;",
      "+ this.timestamp = System.currentTimeMillis();",
      "+ }",
      "+",
      "+ boolean shouldRetry()",
      "+ {",
      "+ return MessagingService.DROPPABLE_VERBS.contains(message.getVerb());",
      "+ }",
      "+ }",
      "+",
      "+ private static class RetriedEntry extends Entry",
      "+ {",
      "+ RetriedEntry(Entry e)",
      "+ {",
      "+ super(e.message, e.id);",
      "+ }",
      "+",
      "+ boolean shouldRetry()",
      "+ {",
      "+ return false;",
      "}",
      "}",
      "}",
      ""
    ]
  }
}