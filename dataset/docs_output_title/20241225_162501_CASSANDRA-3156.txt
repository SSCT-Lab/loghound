{
  "p": [
    "Cassandra-3156",
    "Assertion error in RowRepairResolver"
  ],
  "(1) Log information": {
    "p": [
      "Background: Row Repair is to check and fix the inconsistent row data. During row repair, coordinator first reads data from the nearest replica, and the data digest from other replicas. If there is a mismatch, coordinator will send data reads to all replicas for repair.",
      "The following logs happen on a coordinator who does not have a copy of the data.",
      "DEBUG 03:15:59,866 Processing response on a callback from 3840@/10.179.64.227",
      "DEBUG 03:15:59,866 Preprocessed data response",
      "DEBUG 03:15:59,866 Processing response on a callback from 3841@/10.179.111.137",
      "DEBUG 03:15:59,866 Preprocessed digest response",
      "DEBUG 03:15:59,865 Processing response on a callback from 3837@/10.179.111.137",
      "DEBUG 03:15:59,865 Preprocessed data response",
      "DEBUG 03:15:59,865 Preprocessed data response",
      "DEBUG 03:15:59,867 Preprocessed digest response",
      "DEBUG 03:15:59,867 resolving 2 responses",
      "ERROR03:15:59,866 Fatal exception in thread Thread[ReadRepairStage:526,5,main]",
      "java.lang.AssertionError",
      "at org.apache.cassandra.service.RowRepairResolver.resolve(RowRepairResolver.java:77)",
      "at org.apache.cassandra.service.AsyncRepairCallback$1.runMayThrow(AsyncRepairCallback.java:54)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:30)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
      "at java.lang.Thread.run(Thread.java:662)",
      "ERROR 03:15:59,866 Fatal exception in thread Thread[ReadRepairStage:525,5,main]",
      "java.lang.AssertionError",
      "at org.apache.cassandra.service.RowRepairResolver.resolve(RowRepairResolver.java:77)",
      "at org.apache.cassandra.service.AsyncRepairCallback$1.runMayThrow(AsyncRepairCallback.java:54)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:30)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
      "at java.lang.Thread.run(Thread.java:662)",
      "ERROR 03:15:59,867 Fatal exception in thread Thread[ReadRepairStage:528,5,main]",
      "java.lang.AssertionError",
      "at org.apache.cassandra.service.RowRepairResolver.resolve(RowRepairResolver.java:77)",
      "at org.apache.cassandra.service.AsyncRepairCallback$1.runMayThrow(AsyncRepairCallback.java:54)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:30)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
      "at java.lang.Thread.run(Thread.java:662)",
      "DEBUG 03:15:59,867 resolving 2 responses",
      "DEBUG 03:15:59,867 resolving 2 responses",
      "DEBUG 03:15:59,867 resolving 2 responses"
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "Based on the error symptom log, we can locate the statement where the ERROR is triggered during RowRepair:",
      "publicRow resolve()throwsDigestMismatchException, IOException",
      "{",
      "if(logger.isDebugEnabled())",
      "logger.debug(\"resolving \"+replies.size() +\" responses\");",
      "...",
      "if(replies.size() >1)",
      "{",
      "...",
      "for(Map.Entry<Message, ReadResponse> entry :replies.entrySet())",
      "{",
      "Message message = entry.getKey();",
      "ReadResponse response = entry.getValue();",
      "ColumnFamily cf = response.row().cf;",
      "assert!response.isDigestQuery() :\"Received digest response to repair read from \"+ entry.getKey().getFrom();",
      "versions.add(cf);",
      "endpoints.add(message.getFrom());",
      "...",
      "}",
      "...",
      "}",
      "else{...}",
      "if(logger.isDebugEnabled())",
      "logger.debug(\"resolve: \"+ (System.currentTimeMillis() - startTime) +\" ms.\");",
      "return newRow(key, resolved);",
      "}",
      "The assert condition (!response.isDigestQuery()) indicates that when coordinator sends a data request, it receives a digest.",
      "On the other hand, the reporter also complains that “some spurious digest mismatches mixed in” as follows:",
      "DEBUG 03:15:59,823 Digest mismatch:",
      "org.apache.cassandra.service.DigestMismatchException: Mismatch for key DecoratedKey(20580074455139572311737153648595094740, 30363933) (fb3f10b793298382b554737490bc78b5 vs db8d74ec919be7c1a1dda15c85754eb0)",
      "at org.apache.cassandra.service.RowDigestResolver.resolve(RowDigestResolver.java:105)",
      "at org.apache.cassandra.service.RowDigestResolver.resolve(RowDigestResolver.java:30)",
      "at org.apache.cassandra.service.ReadCallback$AsyncRepairRunner.runMayThrow(ReadCallback.java:229)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:30)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
      "at java.lang.Thread.run(Thread.java:662)",
      "This happens when coordinator does not have a copy of the data, therefore, this digest must come from the other node.",
      "Based on the above two cases, it seems that there is something wrong with the input of this coordinator.",
      "After checking the source code for receiving message, we find that the code did not reset the buffer before each use.",
      "public voidreceive(Message message, String id)MessagingService.java",
      "{...",
      "Runnable runnable =newMessageDeliveryTask(message, id);",
      "ExecutorService stage = StageManager.getStage(message.getMessageType());",
      "assertstage !=null:\"No stage for message type \"+ message.getMessageType();",
      "stage.execute(runnable);",
      "}",
      "",
      "public voidrun()MessageDeliveryTask.java",
      "{...",
      "IVerbHandlerverbHandler= MessagingService.instance().getVerbHandler(verb);",
      "...",
      "verbHandler.doVerb(message,id);",
      "}",
      "",
      "public voiddoVerb(Message message, String id)ReadVerbHandler.java",
      "{...",
      "try{",
      "FastByteArrayInputStream in =newFastByteArrayInputStream(message.getMessageBody());",
      "ReadCommand command = ReadCommand.serializer().deserialize(newDataInputStream(in), message.getVersion());",
      "Table table = Table.open(command.table);",
      "Row row = command.getRow(table);",
      "DataOutputBufferout=threadLocalOut.get();",
      "ReadResponse.serializer().serialize(getResponse(command, row),out, message.getVersion());",
      "...",
      "}",
      "catch(IOException ex)",
      "{",
      "throw newRuntimeException(ex);",
      "}",
      "}"
    ]
  },
  "(3) Root Cause": {
    "p": [
      "The buffer for receiving messages is not reset before use, so the data from previous usage may mix in, and affect the correctness of the program."
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the error. Fix the incorrect semantic.",
      "•/src/java/org/apache/cassandra/db/ReadVerbHandler.java",
      "public voiddoVerb(Message message, String id)",
      "{...",
      "try{",
      "FastByteArrayInputStream in =newFastByteArrayInputStream(message.getMessageBody());",
      "ReadCommand command = ReadCommand.serializer().deserialize(newDataInputStream(in), message.getVersion());",
      "Table table = Table.open(command.table);",
      "Row row = command.getRow(table);",
      "DataOutputBuffer out =threadLocalOut.get();",
      "+out.reset();",
      "ReadResponse.serializer().serialize(getResponse(command, row), out, message.getVersion());",
      "...",
      "}",
      "catch(IOException ex){...}",
      "}",
      ""
    ]
  }
}