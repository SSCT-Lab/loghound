{
  "p": [
    "Cassandra-2773",
    "Index manager cannot support deleting and inserting into a row in the same mutation"
  ],
  "(1) Log information": {
    "p": [
      "Settings: I use hector 0.8.0-1 and cassandra 0.8.",
      "1. create mutator by using hector api,",
      "2. Insert a few columns into the mutator for key \"key1\", cf \"standard\".",
      "3. add a deletion to the mutator to delete the record of \"key1\", cf \"standard\".",
      "4. repeat 2 and 3",
      "5. execute the mutator.",
      "The result: the connection seems to be held by the sever forever, it never returns. when I tried to restart the cassandra I saw unsupportedexception: \"Index manager cannot support deleting and inserting into a row in the same mutation, and the cassandra is dead forever, unless I delete the commitlog.” (Hang)",
      "I would expect to get an exception when I execute the mutator, not after I restart the cassandra.",
      "ERROR 17:20:41,385 Fatal exception in thread Thread[MutationStage:5,5,main]",
      "java.lang.RuntimeException: java.lang.UnsupportedOperationException: Index manager cannot support deleting and inserting into a row in the same mutation",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:34)",
      "at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)",
      "at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)",
      "at java.util.concurrent.FutureTask.run(FutureTask.java:138)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
      "at java.lang.Thread.run(Thread.java:619)",
      "Caused by: java.lang.UnsupportedOperationException: Index manager cannot support deleting and inserting into a row in the same mutation",
      "at org.apache.cassandra.db.Table.ignoreObsoleteMutations(Table.java:431)",
      "at org.apache.cassandra.db.Table.apply(Table.java:387)",
      "at org.apache.cassandra.db.commitlog.CommitLog$2.runMayThrow(CommitLog.java:300)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:30)",
      "... 6 more",
      "ERROR 17:20:41,389 Fatal exception in thread Thread[MutationStage:58,5,main]",
      "java.lang.RuntimeException: java.lang.UnsupportedOperationException: Index manager cannot support deleting and inserting into a row in the same mutation",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:34)",
      "at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)",
      "at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)",
      "at java.util.concurrent.FutureTask.run(FutureTask.java:138)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
      "at java.lang.Thread.run(Thread.java:619)",
      "Caused by: java.lang.UnsupportedOperationException: Index manager cannot support deleting and inserting into a row in the same mutation",
      "at org.apache.cassandra.db.Table.ignoreObsoleteMutations(Table.java:431)",
      "at org.apache.cassandra.db.Table.apply(Table.java:387)",
      "at org.apache.cassandra.db.commitlog.CommitLog$2.runMayThrow(CommitLog.java:300)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:30)",
      "... 6 more",
      "this ERROR will repeat..."
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "Executing insert and delete in the same mutation is not supported in current Cassandra. When the client executes this operation, Cassandra cluster returns nothing and hangs. That is, Cassandra stops responding.",
      "Restart the cluster cannot restore the problem until the commit log is deleted.",
      "Based on the stack trace and the source code, we can locate the statement which triggers the error exception.",
      "private static voidignoreObsoleteMutations(ColumnFamily cf, SortedSet<ByteBuffer> mutatedIndexedColumns, ColumnFamily oldIndexedColumns)",
      "{",
      "if(oldIndexedColumns ==null)",
      "return;",
      "",
      "for(Iterator<ByteBuffer> iter = mutatedIndexedColumns.iterator(); iter.hasNext(); )",
      "{",
      "ByteBuffer name = iter.next();",
      "IColumn newColumn = cf.getColumn(name);// null == row delete or it wouldn't be marked Mutated",
      "if(newColumn !=null&& cf.isMarkedForDelete())",
      "throw newUnsupportedOperationException(\"Index manager cannot support deleting and inserting into a row in the same mutation\");",
      "IColumn oldColumn = oldIndexedColumns.getColumn(name);",
      "",
      "// deletions are irrelevant to the index unless we're changing state from live -> deleted, i.e.,",
      "// just updating w/ a newer tombstone doesn't matter",
      "booleanbothDeleted = (newColumn ==null|| newColumn.isMarkedForDelete())",
      "&& (oldColumn ==null|| oldColumn.isMarkedForDelete());",
      "// obsolete means either the row or the column timestamp we're applying is older than existing data",
      "booleanobsoleteRowTombstone = newColumn ==null&& oldColumn !=null&& cf.getMarkedForDeleteAt() < oldColumn.timestamp();",
      "booleanobsoleteColumn = newColumn !=null&& (newColumn.timestamp() <= oldIndexedColumns.getMarkedForDeleteAt()",
      "|| (oldColumn !=null&& oldColumn.reconcile(newColumn) == oldColumn));",
      "if(bothDeleted || obsoleteRowTombstone || obsoleteColumn)",
      "{",
      "if(logger.isDebugEnabled())",
      "logger.debug(\"skipping index update for obsolete mutation of \"+ cf.getComparator().getString(name));",
      "iter.remove();",
      "oldIndexedColumns.remove(name);",
      "}",
      "}",
      "}"
    ]
  },
  "(3) Root Cause": {
    "p": [
      "There is race condition within insert and delete. When hector calls the unsupported operation, the exception is thrown.",
      "When the user operates in a wrong way, the server should “at least response an error or exception...not just hold the connection and do nothing”. “In addition, the server should not be dead forever, when this kind of exception occurs.”"
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the error. Allowing deleteing a row and updating columns in it in the same mutation.",
      "Consider the unsupported operation in more detail. Transform the mutation into supported operation in the certain condition.",
      "•src/java/org/apache/cassandra/db/Table.java",
      "private static voidignoreObsoleteMutations(ColumnFamily cf, SortedSet<ByteBuffer> mutatedIndexedColumns, ColumnFamily oldIndexedColumns)",
      "{",
      "+// DO NOT modify the cf object here, it can race w/ the CL write (see https://issues.apache.org/jira/browse/CASSANDRA-2604)",
      "+",
      "if(oldIndexedColumns ==null)",
      "return;",
      "",
      "for(Iterator<ByteBuffer> iter = mutatedIndexedColumns.iterator(); iter.hasNext(); )",
      "{",
      "ByteBuffer name = iter.next();",
      "IColumn newColumn = cf.getColumn(name);// null == row delete or it wouldn't be marked Mutated",
      "if(newColumn !=null&& cf.isMarkedForDelete())",
      "throw newUnsupportedOperationException(\"Index manager cannot support deleting and inserting into a row in the same mutation\");",
      "+{",
      "+// row is marked for delete, but column was also updated. if column is timestamped less than",
      "+// the row tombstone, treat it as if it didn't exist. Otherwise we don't care about row",
      "+// tombstone for the purpose of the index update and we can proceed as usual.",
      "+if (newColumn.timestamp() <= cf.getMarkedForDeleteAt())",
      "+{",
      "+// don't remove from the cf object; that can race w/ CommitLog write. Leaving it is harmless.",
      "+newColumn = null;",
      "+}",
      "+}",
      "IColumn oldColumn = oldIndexedColumns.getColumn(name);",
      "...",
      "}",
      "}",
      "",
      ""
    ]
  }
}