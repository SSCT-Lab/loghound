{
  "p": [
    "Cassandra-5631",
    "NPE when creating column family shortly after multinode startup"
  ],
  "(1) Log information": {
    "p": [
      "When testing a 2-node cluster and creating a column familyright afterthe nodes startup, using the Astyanax client. Sometimes column family creation fails and see NPEs on the cassandra server:",
      "2013-06-12 14:55:31,773 ERROR CassandraDaemon [MigrationStage:1] - Exception in thread Thread[MigrationStage:1,5,main]",
      "java.lang.NullPointerException",
      "at org.apache.cassandra.db.DefsTable.addColumnFamily(DefsTable.java:510)",
      "at org.apache.cassandra.db.DefsTable.mergeColumnFamilies(DefsTable.java:444)",
      "at org.apache.cassandra.db.DefsTable.mergeSchema(DefsTable.java:354)",
      "at org.apache.cassandra.db.DefinitionsUpdateVerbHandler$1.runMayThrow(DefinitionsUpdateVerbHandler.java:55)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:28)",
      "at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)",
      "at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)",
      "at java.util.concurrent.FutureTask.run(FutureTask.java:166)",
      "at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)",
      "at java.lang.Thread.run(Thread.java:722)",
      "",
      "2013-06-12 14:55:31,880 ERROR CassandraDaemon [MigrationStage:1] - Exception in thread Thread[MigrationStage:1,5,main]",
      "java.lang.NullPointerException",
      "at org.apache.cassandra.db.DefsTable.mergeColumnFamilies(DefsTable.java:475)",
      "at org.apache.cassandra.db.DefsTable.mergeSchema(DefsTable.java:354)",
      "at org.apache.cassandra.db.DefinitionsUpdateVerbHandler$1.runMayThrow(DefinitionsUpdateVerbHandler.java:55)",
      "at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:28)",
      "at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)",
      "at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)",
      "at java.util.concurrent.FutureTask.run(FutureTask.java:166)",
      "at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)",
      "at java.lang.Thread.run(Thread.java:722)"
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "Based on the line number in stack trace and the source code, we can locate the statement where these two NPE triggers respectively.",
      "private static voidaddColumnFamily(CFMetaData cfm)",
      "{",
      "assertSchema.instance.getCFMetaData(cfm.ksName, cfm.cfName) ==null;",
      "KSMetaDataksm= Schema.instance.getTableDefinition(cfm.ksName);",
      "ksm = KSMetaData.cloneWith(ksm, Iterables.concat(ksm.cfMetaData().values(), Collections.singleton(cfm)));",
      "",
      "Schema.instance.load(cfm);",
      "",
      "// make sure it's init-ed w/ the old definitions first,",
      "// since we're going to call initCf on the new one manually",
      "Table.open(cfm.ksName);",
      "",
      "Schema.instance.setTableDefinition(ksm);",
      "",
      "if(!StorageService.instance.isClientMode())",
      "{",
      "Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName,true);",
      "MigrationManager.instance.notifyCreateColumnFamily(cfm);",
      "}",
      "}",
      "",
      "private static voidmergeColumnFamilies(Map<DecoratedKey, ColumnFamily> old, Map<DecoratedKey, ColumnFamily> updated)",
      "throwsConfigurationException, IOException",
      "{...",
      "for(DecoratedKey keyspace : modifiedEntries.keySet())",
      "{...",
      "if(prevValue.isEmpty())// whole keyspace was deleted and now it's re-created",
      "{...}",
      "else if(newValue.isEmpty())// whole keyspace is deleted",
      "{...}",
      "else// has modifications in the nested ColumnFamilies, need to perform nested diff to determine what was really changed",
      "{",
      "StringksName= AsciiType.instance.getString(keyspace.key);",
      "",
      "Map<String, CFMetaData> oldCfDefs =newHashMap<String, CFMetaData>();",
      "for(CFMetaData cfm : Schema.instance.getKSMetaData(ksName).cfMetaData().values())",
      "oldCfDefs.put(cfm.cfName, cfm);",
      "...",
      "}",
      "}",
      "}",
      "Then we can infer that for the first NPE which occurs inaddColumnFamily(),NPE is thrown becauseSchema.instance.getTableDefinition()returns null for the specific keyspace. Then without checking this value is being referenced."
    ]
  },
  "(3) Root Cause": {
    "p": [
      "It is possible that the node which throws NPE does not get create keyspace message before getting create cloumnFamily message, or the ordering of these two messages is not correct."
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the error.",
      "The patch sends the keyspace mutation serialized along with any column families update/create/drop migration, so that NPE can be eliminated.",
      "â€¢/src/java/org/apache/cassandra/service/MigrationManager.java",
      "@@ -210,7 +210,7 @@ public class MigrationManager",
      "throw new AlreadyExistsException(cfm.ksName, cfm.cfName);",
      "",
      "logger.info(String.format(\"Create new ColumnFamily: %s\", cfm));",
      "- announce(cfm.toSchema(FBUtilities.timestampMicros()));",
      "+ announce(serializeKeyspace(cfm.toSchema(FBUtilities.timestampMicros()), cfm.ksName));",
      "}",
      "",
      "public static void announceKeyspaceUpdate(KSMetaData ksm) throws ConfigurationException",
      "@@ -236,7 +236,7 @@ public class MigrationManager",
      "oldCfm.validateCompatility(cfm);",
      "",
      "logger.info(String.format(\"Update ColumnFamily '%s/%s' From %s To %s\", cfm.ksName, cfm.cfName, oldCfm, cfm));",
      "- announce(oldCfm.toSchemaUpdate(cfm, FBUtilities.timestampMicros()));",
      "+ announce(serializeKeyspace(oldCfm.toSchemaUpdate(cfm, FBUtilities.timestampMicros()), cfm.ksName));",
      "}",
      "",
      "public static void announceKeyspaceDrop(String ksName) throws ConfigurationException",
      "@@ -256,7 +256,14 @@ public class MigrationManager",
      "throw new ConfigurationException(String.format(\"Cannot drop non existing column family '%s' in keyspace '%s'.\", cfName, ksName));",
      "",
      "logger.info(String.format(\"Drop ColumnFamily '%s/%s'\", oldCfm.ksName, oldCfm.cfName));",
      "- announce(oldCfm.dropFromSchema(FBUtilities.timestampMicros()));",
      "+ announce(serializeKeyspace(oldCfm.dropFromSchema(FBUtilities.timestampMicros()), ksName));",
      "+ }",
      "+",
      "+ // Include the serialized keyspace for when a target node missed the CREATE KEYSPACE migration (see #5631).",
      "+ private static RowMutation serializeKeyspace(RowMutation migration, String ksName)",
      "+ {",
      "+ migration.add(SystemTable.readSchemaRow(ksName).cf);",
      "+ return migration;",
      "}",
      "",
      ""
    ]
  }
}