{
  "p": [
    "MAPREDUCE-2995",
    "MR AM crashes when a container-launch hangs on a faulty NM"
  ],
  "(1) Log information": {
    "(1.1) Roles in this case": {
      "p": [
        "AM NM RM"
      ]
    },
    "(1.2) Symptoms": {
      "p": [
        "Description of this bug: “AM tries to launch containers on a faulty node which blocks several/all of the StartContainer requests. Eventually, RM expires the container-allocations, informs the AM about container-expiry. But AM crashes with an INTERNAL_ERROR as the event is unexpected.”",
        "AM’s log is provided.",
        "11/09/12 14:11:38 ERROR impl.TaskAttemptImpl: Can't handle this event at current state",
        "org.apache.hadoop.yarn.state.InvalidStateTransitonException: Invalid event: TA_CONTAINER_COMPLETED at ASSIGNED",
        "at org.apache.hadoop.yarn.state.StateMachineFactory.doTransition(StateMachineFactory.java:297)",
        "at org.apache.hadoop.yarn.state.StateMachineFactory.access$300(StateMachineFactory.java:39)",
        "at org.apache.hadoop.yarn.state.StateMachineFactory$InternalStateMachine.doTransition(StateMachineFactory.java:439)",
        "at org.apache.hadoop.mapreduce.v2.app.job.impl.TaskAttemptImpl.handle(TaskAttemptImpl.java:903)",
        "at org.apache.hadoop.mapreduce.v2.app.job.impl.TaskAttemptImpl.handle(TaskAttemptImpl.java:127)",
        "at org.apache.hadoop.mapreduce.v2.app.MRAppMaster$TaskAttemptEventDispatcher.handle(MRAppMaster.java:543)",
        "at org.apache.hadoop.mapreduce.v2.app.MRAppMaster$TaskAttemptEventDispatcher.handle(MRAppMaster.java:536)",
        "at org.apache.hadoop.yarn.event.AsyncDispatcher.dispatch(AsyncDispatcher.java:113)",
        "at org.apache.hadoop.yarn.event.AsyncDispatcher$1.run(AsyncDispatcher.java:75)",
        "at java.lang.Thread.run(Thread.java:619)"
      ]
    }
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "",
      "Figure 1. State Machine for container in RM (partial)Figure 2. State Machine for TaskAttemp in AM (partial)",
      "",
      "Based on the description, we can get the corresponding details:",
      "RM maintained a state machine for each container (Figure 1). When RM allocated a container C1 to an application, C1’s state was ALLOCATED. (Note: AM had not obtained this container at this time)",
      "(1)AM would obtain the allocated container C1 through its heartbeat by RPC function AMRMProtocol.allocate(), and C1’s state changed to ACQUIRED. C1 would be registered with the component ContainerAllocationExpirer in RM.",
      "AM assigned the container C1 to the TaskAttempt TA1, which triggered the event TA_ASSIGNED. The state machine for each TaskAttempt was maintained in AM (Figure 2). So TA1’s state changed from UNASSIGNED to ASSIGNED.",
      "(2)AM’s ContainerLaucher sent “startContainer” request to NM’s ContainerManager.",
      "(3)In the normal case. When NM’s ContainerManager received the “startContainer” request, it will launch C1. Since NM’s NodeStatusUpdater will report all the containers information through RPC.NodeHeartBeat() to RM periodically, RM will be informed that C1 is lauched. Then C1’s state in RM will change to Running, and it will be unregistered with RM’s ContainerAllocationExpirer.",
      "(3)*In this bug, since the current NM was a faulty node which blocked several/all of the StartContainer requests, C1 couldn’t be launched in this NM. So RM could not receive the message about C1’s launch. RM’s ContainerAllocationExpirer would handle this case after the container expiration time (default 10 mins). As a result, C1’s state in RM changed to EXPIRED, and RM would inform AM of C1’s expiry through AM’s heartbeat. And this triggerd the event TA_CONTAINER_COMPLETED. Sincethere was notcorresponding state transition to handle thiscase, theerror happened.",
      "",
      "",
      "According to the log, TA’s current state is ASSIGNED:",
      "11/09/12 14:11:38 ERROR impl.TaskAttemptImpl: Can't handle this event atcurrent state",
      "org.apache.hadoop.yarn.state.InvalidStateTransitonException: Invalid event: TA_CONTAINER_COMPLETEDatASSIGNED",
      "",
      "Based on the state machine of TaskAttempt, we can infer that the allocated container hasn’t been launched by NM, and there may be something wrong with the node which the container belongs to."
    ]
  },
  "(3) Root Cause": {
    "p": [
      "The node (where the container allocated by RM is located) was faulty, and blocked the containers to be started. So RM expired the container and informed AM. But in AM, there is no corresponding transition to handle the TaskAttemp event “TA_CONTAINER_COMPLETED” at current state “ASSIGNED”, and the error happened."
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the error.",
      "Add the corresponding transition to AM’s TaskAttemp: If the event TA_CONTAINER_COMPLETED happens, TaskAttempt’s state will change from ASSIGNED to FAIL_CONTAINER_CLEANUP, and trigger the operation of “CLEANUP_CONTAINER_TRANSITION”.",
      "· hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "@@ -204,6 +204,11 @@ public abstract class TaskAttemptImpl implements",
      ".addTransition(TaskAttemptState.ASSIGNED, TaskAttemptState.FAILED,",
      "TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED,",
      "new DeallocateContainerTransition(TaskAttemptState.FAILED, false))",
      "+ .addTransition(TaskAttemptState.ASSIGNED,",
      "+ TaskAttemptState.FAIL_CONTAINER_CLEANUP,",
      "+ TaskAttemptEventType.TA_CONTAINER_COMPLETED,",
      "+ CLEANUP_CONTAINER_TRANSITION)",
      "+ // ^ If RM kills the container due to expiry, preemption etc.",
      ".addTransition(TaskAttemptState.ASSIGNED,",
      "TaskAttemptState.KILL_CONTAINER_CLEANUP,",
      "TaskAttemptEventType.TA_KILL, CLEANUP_CONTAINER_TRANSITION)",
      "@@ -925,7 +930,8 @@ public abstract class TaskAttemptImpl implements",
      "try {",
      "",
      "stateMachine.doTransition(event.getType(), event);",
      "} catch (InvalidStateTransitonException e) {",
      "- LOG.error(\"Can't handle this event at current state\", e);",
      "+ LOG.error(\"Can't handle this event at current state for \"",
      "+ + this.attemptId, e);Add the TaskAttempt id to the error message.",
      "eventHandler.handle(new JobDiagnosticsUpdateEvent(",
      "this.attemptId.getTaskId().getJobId(), \"Invalid event \" + event.getType() +",
      "\" on TaskAttempt \" + this.attemptId));",
      "",
      "•hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskImpl.java",
      "@@ -528,7 +528,8 @@ public abstract class TaskImpl implements Task, EventHandler<TaskEvent> {",
      "",
      "try {",
      "stateMachine.doTransition(event.getType(), event);",
      "} catch (InvalidStateTransitonException e) {",
      "- LOG.error(\"Can't handle this event at current state\", e);",
      "+ LOG.error(\"Can't handle this event at current state for \"",
      "+ + this.taskId, e);Add the task id to the error message.",
      "internalError(event.getType());",
      "}",
      "if (oldState != getState()) {"
    ]
  },
  "(5) How many nodes are involved in the patch? (multiple/single node(s))": {
    "p": [
      "Since AM is in charge of the implementation of each task, task attempt, so the fixes are applied to AM."
    ]
  },
  "(6) Code Snippets": {
    "p": [
      "In MRAppMaster(AM), there is an important “AsyncDispatcher”, and it is reponsible for message scheduling. Besides, there are also other the message scheduler: JobEventDispatcher, TaskEventDispatcher,TaskAttemptEventDispatcher, SpeculatorEventDispatcher etc. When AM intializes, they will also be added. And the AsyncDispatcher will dispatch the event to the corresponding dispatcher.",
      "In class MRAppMaster,",
      "protected static voidinitAndStartAppMaster(finalMRAppMaster appMaster,",
      "finalYarnConfiguration conf, String jobUserName)throwsIOException,",
      "InterruptedException {",
      "UserGroupInformation.setConfiguration(conf);",
      "UserGroupInformation appMasterUgi = UserGroupInformation",
      ".createRemoteUser(jobUserName);",
      "appMasterUgi.doAs(newPrivilegedExceptionAction<Object>() {",
      "@Override",
      "publicObject run()throwsException {appMaster.init(conf);",
      "appMaster.start();return null; } });",
      "}",
      "",
      "publicvoidinit() { …",
      "dispatcher=newAsyncDispatcher();",
      "…",
      "//register the event dispatchers",
      "dispatcher.register(JobEventType.class,jobEventDispatcher);",
      "dispatcher.register(TaskEventType.class,newTaskEventDispatcher());",
      "dispatcher.register(TaskAttemptEventType.class,newTaskAttemptEventDispatcher());",
      "dispatcher.register(TaskCleaner.EventType.class,taskCleaner);",
      "…",
      "}",
      "",
      "public voidstart() {",
      "//start all the components",
      "super.start();",
      "eventHandlingThread=newThread(createThread());",
      "eventHandlingThread.setName(\"AsyncDispatcher event handler\");",
      "eventHandlingThread.start();",
      "}",
      "",
      "Runnable createThread() {return newRunnable() {",
      "@Override",
      "public voidrun() {",
      "while(!stopped&& !Thread.currentThread().isInterrupted()) {",
      "Event event;",
      "try{ event =eventQueue.take();// Get the message from the central dispatcher’s message queue",
      "}catch(InterruptedException ie) {LOG.info(\"AsyncDispatcher thread interrupted\", ie);",
      "return;",
      "}",
      "if(event !=null) { dispatch(event);// Dispatch the message}",
      "}",
      "}",
      "};",
      "}",
      "",
      "MRAppMaster’s Event-Flow Graph:the event “TA_CONTAINER_COMPLETED” will handled by TaskAttemptEventDispatcher",
      "private classTaskAttemptEventDispatcher",
      "implementsEventHandler<TaskAttemptEvent> {",
      "@SuppressWarnings(\"unchecked\")",
      "@Override",
      "public voidhandle(TaskAttemptEvent event) {",
      "Job job =context.getJob(event.getTaskAttemptID().getTaskId().getJobId());",
      "Task task = job.getTask(event.getTaskAttemptID().getTaskId());",
      "TaskAttempt attempt = task.getAttempt(event.getTaskAttemptID());",
      "((EventHandler<TaskAttemptEvent>) attempt).handle(event);",
      "}",
      "}",
      "public voidhandle(TaskAttemptEvent event) {TaskAttemptImpl.java",
      "…",
      "writeLock.lock();",
      "try{finalTaskAttemptState oldState = getState();",
      "try{stateMachine.doTransition(event.getType(), event);",
      "}catch(InvalidStateTransitonExceptione) {",
      "LOG.error(\"Can't handle this event at current statefor \" +this.attemptId, e);",
      "eventHandler.handle(newJobDiagnosticsUpdateEvent(",
      "this.attemptId.getTaskId().getJobId(), \"Invalid event \" + event.getType() + \" on TaskAttempt \" +this.attemptId));",
      "eventHandler.handle(newJobEvent(this.attemptId.getTaskId().getJobId(), JobEventType.INTERNAL_ERROR));",
      "}",
      "if(oldState != getState()) {LOG.info(attemptId+ \" TaskAttempt Transitioned from \" + oldState + \" to \"+ getState());}",
      "}finally{writeLock.unlock(); }",
      "}",
      "",
      ""
    ]
  }
}