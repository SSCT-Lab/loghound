{
  "p": [
    "MAPREDUCE-2953",
    "JobClient fails due to a race in RM, removes staged files and in turn crashes MR AM"
  ],
  "(1) Log information": {
    "(1.1) Roles in this case": {
      "p": [
        "JobClient: client side RM:server side"
      ]
    },
    "(1.2) Symptoms": {
      "p": [
        "MR JobClient crashes immediately. Client’s log is as follows:",
        "11/09/08 10:52:35 INFO mapreduce.JobSubmitter: number of splits:2094",
        "11/09/08 10:52:36 INFO mapred.YARNRunner: AppMaster capability = memory: 2048,",
        "11/09/08 10:52:36 INFO mapred.YARNRunner: Command to launch container for ApplicationMaster is : $JAVA_HOME/bin/java -Dhadoop.root.logger=INFO,console -Xmx1536m org.apache.hadoop.mapreduce.v2.app.MRAppMaster 1315478927026 1 <FAILCOUNT> 1><LOG_DIR>/stdout 2><LOG_DIR>/stderr",
        "11/09/08 10:52:36 INFO mapred.ResourceMgrDelegate: Submitted application application_1315478927026_1 to ResourceManager",
        "11/09/08 10:52:36 INFO mapreduce.JobSubmitter: Cleaning up the staging area /user/gridperf/.staging/job_1315478927026_0001",
        "RemoteTrace:",
        "at Local Trace:",
        "org.apache.hadoop.yarn.exceptions.impl.pb.YarnRemoteExceptionPBImpl: failed to run job",
        "at org.apache.hadoop.yarn.factories.impl.pb.YarnRemoteExceptionFactoryPBImpl.createYarnRemoteException(YarnRemoteExceptionFactoryPBImpl.java:39)",
        "at org.apache.hadoop.yarn.ipc.RPCUtil.getRemoteException(RPCUtil.java:47)",
        "at org.apache.hadoop.mapred.YARNRunner.submitJob(YARNRunner.java:250)",
        "at org.apache.hadoop.mapreduce.JobSubmitter.submitJobInternal(JobSubmitter.java:377)",
        "at org.apache.hadoop.mapreduce.Job$2.run(Job.java:1072)",
        "at org.apache.hadoop.mapreduce.Job$2.run(Job.java:1069)",
        "at java.security.AccessController.doPrivileged(Native Method)",
        "at javax.security.auth.Subject.doAs(Subject.java:396)",
        "at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1135)",
        "at org.apache.hadoop.mapreduce.Job.submit(Job.java:1069)",
        "at org.apache.hadoop.mapreduce.Job.waitForCompletion(Job.java:1089)",
        "at org.apache.hadoop.examples.RandomWriter.run(RandomWriter.java:283)",
        "at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:69)",
        "at org.apache.hadoop.examples.RandomWriter.main(RandomWriter.java:294)",
        "at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
        "at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)",
        "at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)",
        "at java.lang.reflect.Method.invoke(Method.java:597)",
        "at org.apache.hadoop.util.ProgramDriver$ProgramDescription.invoke(ProgramDriver.java:72)",
        "at org.apache.hadoop.util.ProgramDriver.driver(ProgramDriver.java:144)",
        "at org.apache.hadoop.examples.ExampleDriver.main(ExampleDriver.java:68)",
        "at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
        "at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)",
        "at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)",
        "at java.lang.reflect.Method.invoke(Method.java:597)",
        "at org.apache.hadoop.util.RunJar.main(RunJar.java:189)"
      ]
    }
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "",
      "According to the call stack, the application “hadoop.examples.RandomWriter” is running.",
      "（The program RandomWriter uses map/reduce to just run a distributed job where there is no interaction between the tasks and each task write a large unsorted random binary sequence file of BytesWritable.",
      "",
      "We can get the following control flow based on the log and source code.",
      "",
      "",
      "Both the operations “submitApplication” and “getApplicationReport” are realized through RPC protocol ClientRMProtocol between JobClient and RM.",
      "",
      "The logs provided in the bug report only shows the symptom that the JobClient fails to submit the job. And combined with the source code, we get the idea that there is a race between two operations when submitting the job."
    ]
  },
  "(3) Root Cause": {
    "p": [
      "When the application is submitted, it will be created in RMApplicationsManager asynchronously.",
      "At this time, JobClient contacts the RM immediately for the ApplicationReport, gets a null, and then JobClient cleaned up the staging area, which stores the application intermediate file directory on HDFS and used by AM, So AM also crashes.",
      "The relations among these modules are as follows:",
      "ApplicationsManager(not AM) is an important component in RM.",
      ""
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Modify the synchronously call of the RMAppManager handling when submitting an application.",
      "Add synchronization to RMAppManager.submitApplication.",
      "All the fixes are in RM.",
      "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "This fix is in component ApplicationsManager of RM.",
      "",
      "- protected void submitApplication(ApplicationSubmissionContext submissionContext) {",
      "+ protectedsynchronizedvoid submitApplication(ApplicationSubmissionContextsubmissionContext) {",
      "ApplicationId applicationId = submissionContext.getApplicationId();",
      "RMApp application = null;",
      "try {",
      "",
      "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java",
      "@@ -99,7 +99,7 @@",
      "protected NMLivelinessMonitor nmLivelinessMonitor;",
      "protected NodesListManager nodesListManager;",
      "private SchedulerEventDispatcher schedulerDispatcher;",
      "- private RMAppManager rmAppManager;",
      "+ protected RMAppManager rmAppManager;",
      "",
      "private final AtomicBoolean shutdown = new AtomicBoolean(false);",
      "private WebApp webApp;",
      "@@ -176,13 +176,13 @@",
      "masterService = createApplicationMasterService();",
      "addService(masterService) ;",
      "",
      "- clientRM = createClientRMService();",
      "- addService(clientRM);",
      "-",
      "this.rmAppManager = createRMAppManager();",
      "// Register event handler for RMAppManagerEvents",
      "this.rmDispatcher.register(RMAppManagerEventType.class, this.rmAppManager);",
      "+",
      "+ clientRM = createClientRMService();Modify the order of “createClientRMService”, which is used to communicate with the JobClient.",
      "+ addService(clientRM);",
      "",
      "adminService = createAdminService();",
      "addService(adminService);",
      "@@ -441,7 +441,7 @@",
      "}",
      "",
      "protected ClientRMService createClientRMService() {",
      "- return new ClientRMService(this.rmContext, scheduler);",
      "+ return new ClientRMService(this.rmContext, scheduler, this.rmAppManager);",
      "}",
      "",
      "protected ApplicationMasterService createApplicationMasterService() {",
      "",
      "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "@@ -95,6 +95,7 @@",
      "final private YarnScheduler scheduler;",
      "final private RMContext rmContext;",
      "private final AMLivelinessMonitor amLivelinessMonitor;",
      "+ private final RMAppManager rmAppManager;",
      "",
      "@@ -104,11 +105,13 @@",
      "private ApplicationACLsManager aclsManager;",
      "private Map<ApplicationACL, AccessControlList> applicationACLs;",
      "",
      "- public ClientRMService(RMContext rmContext, YarnScheduler scheduler) {",
      "+ public ClientRMService(RMContext rmContext, YarnScheduler scheduler,",
      "+ RMAppManager rmAppManager) {",
      "super(ClientRMService.class.getName());",
      "this.scheduler = scheduler;",
      "this.rmContext = rmContext;",
      "this.amLivelinessMonitor = rmContext.getAMLivelinessMonitor();",
      "+ this.rmAppManager = rmAppManager;",
      "}",
      "",
      "@Override",
      "@@ -205,8 +208,10 @@",
      "throw new IOException(\"Application with id \" + applicationId",
      "+ \" is already present! Cannot add a duplicate!\");",
      "}",
      "- this.rmContext.getDispatcher().getEventHandler().handle(",
      "- new RMAppManagerSubmitEvent(submissionContext));",
      "+ // This needs to be synchronous as the client can query",
      "+ // immediately following the submission to get the application status.",
      "+ // So call handle directly and do not send an event.",
      "+ rmAppManager.handle(new RMAppManagerSubmitEvent(submissionContext));",
      "",
      "LOG.info(\"Application with id \" + applicationId.getId() +",
      "\" submitted by user \" + user + \" with \" + submissionContext);"
    ]
  },
  "(5) How many nodes are involved in the patch? (multiple/single node(s))": {
    "p": [
      "The fixes are all in RM, so only RM is involved."
    ]
  },
  "(6) Code Snippets": {
    "p": [
      "The progress of job submission from a client is as follows:",
      "The user writes an client to submit a job:",
      "// Create a new Job",
      "Job job = new Job(new Configuration()); job.setJarByClass(MyJob.class);",
      "// Specify various job-specific parameters",
      "job.setJobName(\"myjob\");",
      "job.setInputPath(new Path(\"in\")); job.setOutputPath(new Path(\"out\"));",
      "job.setMapperClass(MyJob.MyMapper.class); job.setReducerClass(MyJob.MyReducer.class);",
      "",
      "// Submit the job, then poll for progress until the job is complete",
      "job.waitForCompletion(true);",
      "",
      "",
      "public booleanwaitForCompletion(booleanverbosejob.java",
      ")throwsIOException, InterruptedException, ClassNotFoundException {",
      "if(state== JobState.DEFINE) {submit(); }",
      "……",
      "}",
      "public voidsubmit() //Submit the job to the cluster and return immediately.job.java",
      "throwsIOException, InterruptedException, ClassNotFoundException {",
      "ensureState(JobState.DEFINE);",
      "setUseNewAPI();",
      "connect();",
      "finalJobSubmitter submitter = getJobSubmitter(cluster.getFileSystem(),cluster.getClient());",
      "status=ugi.doAs(newPrivilegedExceptionAction<JobStatus>() {",
      "publicJobStatus run()throwsIOException, InterruptedException,",
      "ClassNotFoundException {returnsubmitter.submitJobInternal(Job.this,cluster); }",
      "});",
      "state= JobState.RUNNING;",
      "}",
      "JobSubmitter.java",
      "JobStatussubmitJobInternal(Job job, Cluster cluster)//Internal method for submitting jobs to the system.",
      "throwsClassNotFoundException, InterruptedException, IOException {",
      "checkSpecs(job);//validate the jobs output specs",
      "",
      "Path jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, job.getConfiguration());",
      "//configure the command line options correctly on the submitting dfs",
      "……",
      "JobID jobId =submitClient.getNewJobID();",
      "job.setJobID(jobId);",
      "Path submitJobDir =newPath(jobStagingArea, jobId.toString());",
      "JobStatus status =null;",
      "try{",
      "...",
      "// Create the splits for the job",
      "LOG.debug(\"Creating splits at \"+jtFs.makeQualified(submitJobDir));",
      "intmaps = writeSplits(job, submitJobDir);",
      "conf.setInt(MRJobConfig.NUM_MAPS, maps);",
      "LOG.info(\"number of splits:\"+ maps);",
      "……",
      "// Now, actually submit the job (using the submit name)",
      "printTokens(jobId, job.getCredentials());",
      "status=submitClient.submitJob(",
      "jobId, submitJobDir.toString(), job.getCredentials());",
      "if(status !=null) {returnstatus;",
      "}else{throw newIOException(\"Could not launch job\"); }",
      "}finally{",
      "if(status == null) {(The status is null, leading to the following errors in logs.)",
      "LOG.info(\"Cleaning up the staging area \"+ submitJobDir);",
      "if(jtFs!=null&& submitJobDir !=null)jtFs.delete(submitJobDir,true);",
      "}",
      "} }",
      "",
      "publicJobStatussubmitJob(JobID jobId, String jobSubmitDir, Credentials ts)YarnRunner.java",
      "throwsIOException, InterruptedException {",
      "Path applicationTokensFile =",
      "newPath(jobSubmitDir, MRJobConfig.APPLICATION_TOKENS_FILE);",
      "try{ ts.writeTokenStorageFile(applicationTokensFile,conf);",
      "}catch(IOException e) {throw newYarnException(e); }",
      "// Construct necessary information to start the MR AM",
      "ApplicationSubmissionContext appContext =",
      "createApplicationSubmissionContext(conf, jobSubmitDir, ts);The following two log entries are printed in this method: LOG.info(\"AppMaster capability = \" + capability); LOG.info(\"Command to launch container for ApplicationMaster is : \" + mergedCommand);",
      "",
      "// Submit to ResourceManager",
      "ApplicationId applicationId =resMgrDelegate.submitApplication(appContext);",
      "",
      "ApplicationReport appMaster =resMgrDelegate.getApplicationReport(applicationId);",
      "String diagnostics = (appMaster ==null?\"application report is null\": appMaster.getDiagnostics());",
      "if(appMaster ==null|| appMaster.getYarnApplicationState() == YarnApplicationState.FAILED",
      "|| appMaster.getYarnApplicationState() == YarnApplicationState.KILLED) {",
      "throw newIOException(\"Failed to run job :\"+ diagnostics);",
      "}",
      "returnclientCache.getClient(jobId).getJobStatus(jobId);",
      "}",
      "ResourceMgrDelegate.java",
      "publicApplicationIdsubmitApplication(ApplicationSubmissionContext appContext)",
      "throwsIOException { ……",
      "applicationsManager.submitApplication(request);",
      "LOG.info(\"Submitted application \"+applicationId+\" to ResourceManager\");",
      "returnapplicationId;",
      "}",
      "",
      "on RM side, in ClientRMService.java",
      "",
      "publicSubmitApplicationResponsesubmitApplication(",
      "SubmitApplicationRequest request)throwsYarnRemoteException {ApplicationSubmissionContext submissionContext = request.getApplicationSubmissionContext();",
      "ApplicationId applicationId = submissionContext.getApplicationId();",
      "String user = submissionContext.getUser();",
      "try{user = UserGroupInformation.getCurrentUser().getShortUserName();if(rmContext.getRMApps().get(applicationId) !=null) {throw newIOException(\"Application with id \"+ applicationId +\" is already present! Cannot add a duplicate!\");}",
      "...",
      "rmAppManager.handle(newRMAppManagerSubmitEvent(submissionContext, System.currentTimeMillis()));",
      "LOG.info(\"Application with id \"+ applicationId.getId() +\" submitted by user \"+ user +\" with \"+ submissionContext);RMAuditLogger.logSuccess(user, AuditConstants.SUBMIT_APP_REQUEST,\"ClientRMService\", applicationId);",
      "}catch(IOException ie) {LOG.info(\"Exception in submitting application\", ie);RMAuditLogger.logFailure(user, AuditConstants.SUBMIT_APP_REQUEST, ie.getMessage(),\"ClientRMService\",\"Exception in submitting application\", applicationId);throwRPCUtil.getRemoteException(ie);}SubmitApplicationResponse response =recordFactory.newRecordInstance(SubmitApplicationResponse.class);returnresponse;}",
      "",
      "",
      "",
      "publicApplicationReportgetApplicationReport(ApplicationId appId)ResourceMgrDelegate.java",
      "throwsYarnRemoteException {",
      "GetApplicationReportRequest request =recordFactory.newRecordInstance(GetApplicationReportRequest.class);",
      "request.setApplicationId(appId);",
      "GetApplicationReportResponse response =applicationsManager.getApplicationReport(request);",
      "ApplicationReport applicationReport = response.getApplicationReport();",
      "returnapplicationReport;",
      "}",
      "",
      "publicGetApplicationReportResponsegetApplicationReport(GetApplicationReportRequest request)ClientRMProtocolPBClientImpl.java",
      "throwsYarnRemoteException {",
      "GetApplicationReportRequestProto requestProto = ((GetApplicationReportRequestPBImpl)request).getProto();",
      "try{",
      "return newGetApplicationReportResponsePBImpl(proxy.getApplicationReport(null, requestProto));",
      "}catch(ServiceExceptione) {",
      "if(e.getCause()instanceofYarnRemoteException) {throw(YarnRemoteException)e.getCause();",
      "}else if(e.getCause()instanceofUndeclaredThrowableException) {",
      "throw(UndeclaredThrowableException)e.getCause();",
      "}else{throw newUndeclaredThrowableException(e); }",
      "}",
      "}",
      "",
      "@OverrideClientRMProtocolPBServiceImpl.java",
      "publicGetApplicationReportResponseProtogetApplicationReport(",
      "RpcController arg0, GetApplicationReportRequestProto proto)throwsServiceException {",
      "GetApplicationReportRequestPBImpl request =newGetApplicationReportRequestPBImpl(proto);",
      "try{",
      "GetApplicationReportResponse response =real.getApplicationReport(request);",
      "return((GetApplicationReportResponsePBImpl)response).getProto();",
      "}catch(YarnRemoteException e) {",
      "throw newServiceException(e);",
      "}",
      "}",
      "",
      "Client communicates with RM through the ClientRMProtocol",
      "With RPC call, in RM side:",
      "",
      "publicGetApplicationReportResponsegetApplicationReport(ClientRMService.java",
      "GetApplicationReportRequest request)throwsYarnRemoteException {",
      "ApplicationId applicationId = request.getApplicationId();",
      "",
      "UserGroupInformation callerUGI;",
      "try{ callerUGI = UserGroupInformation.getCurrentUser();",
      "}catch(IOException ie) {LOG.info(\"Error getting UGI \", ie);",
      "throwRPCUtil.getRemoteException(ie);",
      "}",
      "RMApp application =this.rmContext.getRMApps().get(applicationId);",
      "if(application == null) {throwRPCUtil.getRemoteException(\"Trying to get information for an \"",
      "+\"absent application \"+ applicationId); }",
      "if(!checkAccess(callerUGI, application.getUser(),",
      "ApplicationAccessType.VIEW_APP, applicationId)) {",
      "throwRPCUtil.getRemoteException(newAccessControlException(\"User \"",
      "+ callerUGI.getShortUserName() +\" cannot perform operation \"",
      "+ ApplicationAccessType.VIEW_APP.name() +\" on \"+ applicationId)); }",
      "ApplicationReport report = application.createAndGetApplicationReport();",
      "GetApplicationReportResponse response =recordFactory",
      ".newRecordInstance(GetApplicationReportResponse.class);",
      "response.setApplicationReport(report);",
      "returnresponse;",
      "}",
      "",
      "publicYarnRemoteExceptioncreateYarnRemoteException(String message) {",
      "return newYarnRemoteExceptionPBImpl(message);",
      "}",
      ""
    ]
  }
}