{
  "p": [
    "Cassandra-5133"
  ],
  "Nodes can't rejoin after stopping, when using GossipingPropertyFileSnitch": {},
  "(1) Log information": {
    "p": [
      "The environment setting is: 3 nodes A, B, C.",
      "Node A -> seeds=\"node A ip address\"; Node B -> seeds=\"node A ip address\"; Node C -> seeds=\"node A ip address\"",
      "1) start node A and let it fully start up. ( first node needs to be a seed of itself to start )",
      "2) start node B and let it fully join the ring.",
      "3) start node C and let it fully join the ring.",
      "4) nodetool ring shows all nodes up",
      "5) stop node C and update the cassandra-rackdc.protperites file to rack=2",
      "6) start node C ( fails to start error about can’t find DC for node A, the error log is as follows)",
      "7) stop node A and update seeds=\"node B ip address\", to try and solve question above",
      "8) start node A ( fails to start cant find DC of node C )",
      "9) stuck not being able to start node A and C",
      "ERROR 05:45:39,305 Exception encountered during startup",
      "java.lang.RuntimeException: Could not retrieve DC for /10.114.18.51 from gossip and PFS compatibility is disabled",
      "at org.apache.cassandra.locator.GossipingPropertyFileSnitch.getDatacenter(GossipingPropertyFileSnitch.java:109)",
      "at org.apache.cassandra.locator.DynamicEndpointSnitch.getDatacenter(DynamicEndpointSnitch.java:127)",
      "at org.apache.cassandra.locator.TokenMetadata$Topology.addEndpoint(TokenMetadata.java:1040)",
      "at org.apache.cassandra.locator.TokenMetadata.updateNormalTokens(TokenMetadata.java:185)",
      "at org.apache.cassandra.locator.TokenMetadata.updateNormalTokens(TokenMetadata.java:157)",
      "at org.apache.cassandra.service.StorageService.initServer(StorageService.java:441)",
      "at org.apache.cassandra.service.StorageService.initServer(StorageService.java:397)",
      "at org.apache.cassandra.service.CassandraDaemon.setup(CassandraDaemon.java:309)",
      "at org.apache.cassandra.service.CassandraDaemon.activate(CassandraDaemon.java:397)",
      "at org.apache.cassandra.service.CassandraDaemon.main(CassandraDaemon.java:440)",
      "java.lang.RuntimeException: Could not retrieve DC for /10.114.18.51 from gossip and PFS compatibility is disabled",
      "at org.apache.cassandra.locator.GossipingPropertyFileSnitch.getDatacenter(GossipingPropertyFileSnitch.java:109)",
      "at org.apache.cassandra.locator.DynamicEndpointSnitch.getDatacenter(DynamicEndpointSnitch.java:127)",
      "at org.apache.cassandra.locator.TokenMetadata$Topology.addEndpoint(TokenMetadata.java:1040)",
      "at org.apache.cassandra.locator.TokenMetadata.updateNormalTokens(TokenMetadata.java:185)",
      "at org.apache.cassandra.locator.TokenMetadata.updateNormalTokens(TokenMetadata.java:157)",
      "at org.apache.cassandra.service.StorageService.initServer(StorageService.java:441)",
      "at org.apache.cassandra.service.StorageService.initServer(StorageService.java:397)",
      "at org.apache.cassandra.service.CassandraDaemon.setup(CassandraDaemon.java:309)",
      "at org.apache.cassandra.service.CassandraDaemon.activate(CassandraDaemon.java:397)",
      "at org.apache.cassandra.service.CassandraDaemon.main(CassandraDaemon.java:440)"
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "Combining the exception and the corresponding source code, we know that node C fails to start when psnitch is null.",
      "publicString getDatacenter(InetAddress endpoint)",
      "{",
      "if(endpoint.equals(FBUtilities.getBroadcastAddress()))",
      "returnmyDC;",
      "",
      "EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(endpoint);",
      "if(epState ==null|| epState.getApplicationState(ApplicationState.DC) ==null)",
      "{",
      "if(psnitch==null)",
      "throw newRuntimeException(\"Could not retrieve DC for \"+ endpoint +\" from gossip and PFS compatibility is disabled\");",
      "else",
      "returnpsnitch.getDatacenter(endpoint);",
      "}",
      "returnepState.getApplicationState(ApplicationState.DC).value;",
      "}",
      "",
      "When the ERROR is printed, the node exits.",
      "public static voidmain(String[] args)",
      "{",
      "instance.activate();",
      "}",
      "",
      "public voidactivate()",
      "{",
      "String pidFile = System.getProperty(\"cassandra-pidfile\");",
      "try",
      "{",
      "setup();",
      "if(pidFile !=null)",
      "{",
      "newFile(pidFile).deleteOnExit();",
      "}",
      "if(System.getProperty(\"cassandra-foreground\") ==null)",
      "{",
      "System.out.close();",
      "System.err.close();",
      "}",
      "start();",
      "}",
      "catch(Throwable e)",
      "{",
      "logger.error(\"Exception encountered during startup\", e);",
      "// try to warn user on stdout too, if we haven't already detached",
      "e.printStackTrace();",
      "System.out.println(\"Exception encountered during startup: \"+ e.getMessage());",
      "System.exit(3);",
      "}",
      "}",
      ""
    ]
  },
  "(3) Root Cause": {
    "p": [
      "This is caused by Cassandra-3881, and before that, there is no need to know the dc/rack for saved endpoints at startup."
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the error. Part of the fixed methods are on the stack trace.",
      "Look up the system table for the dc/rack information. A default value is also added, to handle the corner case of contacting a seed the very first time.",
      "•src/java/org/apache/cassandra/locator/GossipingPropertyFileSnitch.java",
      "@@ -39,6 +39,8 @@ public class GossipingPropertyFileSnitch extends AbstractNetworkTopologySnitch",
      "private String myDC;",
      "private String myRack;",
      "private Map<InetAddress, Map<String, String>> savedEndpoints;",
      "+privateStringDEFAULT_DC=\"UNKNOWN_DC\";",
      "+privateStringDEFAULT_RACK=\"UNKNOWN_RACK\";",
      "",
      "publicStringgetDatacenter(InetAddress endpoint)",
      "{",
      "if(endpoint.equals(FBUtilities.getBroadcastAddress()))",
      "returnmyDC;",
      "",
      "EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(endpoint);",
      "if(epState ==null|| epState.getApplicationState(ApplicationState.DC) ==null)",
      "{",
      "if(psnitch==null)",
      "+{",
      "+if(savedEndpoints==null)",
      "+savedEndpoints= SystemTable.loadDcRackInfo();",
      "+if(savedEndpoints.containsKey(endpoint))",
      "+returnsavedEndpoints.get(endpoint).get(\"data_center\");",
      "-throw newRuntimeException(\"Could not retrieve DC for \"+ endpoint +\" from gossip and PFS compatibility is disabled\");",
      "+returnDEFAULT_DC;",
      "+}",
      "else",
      "returnpsnitch.getDatacenter(endpoint);",
      "}",
      "returnepState.getApplicationState(ApplicationState.DC).value;",
      "}",
      "",
      "publicStringgetRack(InetAddress endpoint)",
      "{",
      "if(endpoint.equals(FBUtilities.getBroadcastAddress()))",
      "returnmyRack;",
      "",
      "EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(endpoint);",
      "if(epState ==null|| epState.getApplicationState(ApplicationState.RACK) ==null)",
      "{",
      "if(psnitch==null)",
      "+{",
      "+if(savedEndpoints==null)",
      "+savedEndpoints= SystemTable.loadDcRackInfo();",
      "+if(savedEndpoints.containsKey(endpoint))",
      "+returnsavedEndpoints.get(endpoint).get(\"rack\");",
      "-throw newRuntimeException(\"Could not retrieve rack for \"+ endpoint +\" from gossip and PFS compatibility is disabled\");",
      "+returnDEFAULT_RACK;",
      "+}",
      "else",
      "returnpsnitch.getRack(endpoint);",
      "}",
      "returnepState.getApplicationState(ApplicationState.RACK).value;",
      "}",
      "",
      ""
    ]
  }
}