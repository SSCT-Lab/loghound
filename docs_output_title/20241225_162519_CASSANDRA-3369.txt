{
  "p": [
    "Cassandra-3369",
    "AssertionError when adding a node and doing repair, repair hangs"
  ],
  "(1) Log information": {
    "p": [
      "Two cassandra nodes in the cluster, on one laptop using different 127.0.0.* loopback devices.",
      "The operations are as follows:",
      "1. Started node1 and inserted some data into it using a simple single-threaded testprogram (uses hector 0.8.0-2):",
      "127.0.0.1 datacenter1 rack1 Up Normal 583.55 MB 100.00% Token(bytes[63e5b6995466cd3221cba16646ae19ed])",
      "2. I started another node, node 2 = 127.0.0.2:",
      "127.0.0.2 datacenter1 rack1 Up Normal 147.57 KB 50.00% Token(bytes[4d6ccfeaa8bb59551751a2816fde9343])",
      "127.0.0.1 datacenter1 rack1 Up Normal 583.55 MB 50.00% Token(bytes[63e5b6995466cd3221cba16646ae19ed])",
      "3. I triggered a \"nodetool -h 127.0.0.1 repair\" on the first node that had the data from my test. This repair does not seem to ever end. The nodetool is hanging now but my computer is idle. I get an AssertionError on the first node:",
      "java.lang.AssertionError",
      "at org.apache.cassandra.service.AntiEntropyService$Validator.prepare(AntiEntropyService.java:283)",
      "at org.apache.cassandra.db.compaction.CompactionManager.doValidationCompaction(CompactionManager.java:825)",
      "at org.apache.cassandra.db.compaction.CompactionManager.access$600(CompactionManager.java:63)",
      "at org.apache.cassandra.db.compaction.CompactionManager$6.call(CompactionManager.java:432)",
      "at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)",
      "at java.util.concurrent.FutureTask.run(FutureTask.java:138)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
      "at java.lang.Thread.run(Thread.java:662)",
      "The above exception is thrownrepeatedlyevery few seconds and doesn't seem to stop on the seed node."
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "The assertion error occurs in validator.prepare():",
      "public voidprepare(ColumnFamilyStore cfs)",
      "{",
      "if(tree.partitioner()instanceofRandomPartitioner)",
      "{",
      "// You can't beat an even tree distribution for md5",
      "tree.init();",
      "}",
      "else",
      "{",
      "List<DecoratedKey> keys =newArrayList<DecoratedKey>();",
      "for(DecoratedKey sample : cfs.keySamples(request.range))",
      "{",
      "assertrequest.range.contains(sample.token);",
      "keys.add(sample);",
      "}",
      "...",
      "}",
      "logger.debug(\"Prepared AEService tree of size \"+tree.size() +\" for \"+request);",
      "ranges=tree.invalids();",
      "}",
      "",
      "The sample.token which is checked by the assertion comes from cfs.keySamples():",
      "keySamples -> sstable.getKeySamples() -> getSampleIndexesForRanges()",
      "private staticList<Pair<Integer,Integer>>getSampleIndexesForRanges(...)",
      "{ ...",
      "for(AbstractBounds range : AbstractBounds.normalize(ranges))",
      "{ ...",
      "intleft = Collections.binarySearch(samples,newIndexSummary.KeyPosition(leftKey, -1));",
      "if(left <0)",
      "left = (left +1) * -1;",
      "...",
      "intright = Range.isWrapAround(range.left, range.right)",
      "? samples.size() -1",
      ": Collections.binarySearch(samples,newIndexSummary.KeyPosition(rightKey, -1));",
      "if(right <0)",
      "{",
      "// range are end inclusive so we use the previous index from what binarySearch give us",
      "// since that will be the last index we will return",
      "right = (right +1) * -1;",
      "if(right >0)",
      "right--;",
      "}",
      "",
      "if(left > right)",
      "// empty range",
      "continue;",
      "positions.add(newPair(Integer.valueOf(left), Integer.valueOf(right)));",
      "}",
      "returnpositions;",
      "}",
      "The error can be traced back through the value of the variable that is checked by assertion.",
      "The call relationship related to validator.prepare is as follows:",
      "AntiEntropyService.TreeRequestVerbHandler.doVerb() ® submitValidation() ® doValidationCompaction() ® validator.prepare()",
      "/**",
      "* Trigger a validation compaction which will return the tree upon completion.",
      "*/",
      "public voiddoVerb(Message message, String id)AntiEntropyService.TreeRequestVerbHandler",
      "{...",
      "try",
      "{",
      "TreeRequest remotereq =this.deserialize(buffer, message.getVersion());",
      "TreeRequest request =newTreeRequest(remotereq.sessionid, message.getFrom(), remotereq.range, remotereq.cf);",
      "",
      "// trigger readonly-compaction",
      "ColumnFamilyStore store = Table.open(request.cf.left).getColumnFamilyStore(request.cf.right);",
      "Validator validator =newValidator(request);",
      "logger.debug(\"Queueing validation compaction for \"+ request);",
      "CompactionManager.instance.submitValidation(store, validator);",
      "}",
      "catch(IOException e)",
      "{",
      "throw newIOError(e);",
      "}",
      "}",
      "Since the validation request fails, the response for this request will never come, and the repair hangs.",
      ""
    ]
  },
  "(3) Root Cause": {
    "p": [
      "The case of having no sample keys for one of its token range is not handled correctly.",
      ""
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the error. The fixed file is not on the stack trace.",
      "·/src/java/org/apache/cassandra/io/sstable/SSTableReader.java in getSampleIndexesForRanges():",
      "@@ -429,8 +429,10 @@ public class SSTableReader extends SSTable implements Comparable<SSTableReader>",
      "// range are end inclusive so we use the previous index from what binarySearch give us",
      "// since that will be the last index we will return",
      "right = (right + 1) * -1;",
      "-if (right > 0)",
      "-right--;",
      "+if (right == 0)",
      "+// Means the first key is already stricly greater that the right bound",
      "+continue;",
      "+right--;",
      "}",
      "",
      "if (left >= right)",
      "",
      "Add more information to the log message.",
      "·/src/java/org/apache/cassandra/service/AntiEntropyService.java",
      "@@ -281,7 +281,7 @@ public class AntiEntropyService",
      "List<DecoratedKey> keys = new ArrayList<DecoratedKey>();",
      "for (DecoratedKey sample : cfs.keySamples(request.range))",
      "{",
      "-assert request.range.contains(sample.token);",
      "+assert request.range.contains(sample.token): \"Token \" + sample.token + \" is not within range \"+request.range;",
      "keys.add(sample);",
      "}",
      "",
      ""
    ]
  }
}