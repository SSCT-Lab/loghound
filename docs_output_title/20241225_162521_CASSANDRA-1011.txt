{
  "p": [
    "Cassandra-1011",
    "Exception auto-bootstrapping two nodes nodes at the same time"
  ],
  "(1) Log information": {
    "p": [
      "3 machines in the cluster, and after starting the first node (which is the seed), the other two nodes are brought up at the same time. Then the following exception gets raised on the seed node. Looks like the seed node is assigning the same token to the subnodes at the same time:",
      "ERROR 21:46:49,417 Error in ThreadPoolExecutor",
      "java.lang.RuntimeException: Bootstrap Token collision between /10.0.0.2 and /10.0.0.3 (token Token (bytes[4c617374204d6967726174696f6e])",
      "at org.apache.cassandra.locator.TokenMetadata.addBootstrapToken(TokenMetadata.java:130)",
      "at org.apache.cassandra.service.StorageService.handleStateBootstrap(StorageService.java:548)",
      "at org.apache.cassandra.service.StorageService.onChange(StorageService.java:511)",
      "at org.apache.cassandra.gms.Gossiper.doNotifications(Gossiper.java:705)",
      "at org.apache.cassandra.gms.Gossiper.applyApplicationStateLocally(Gossiper.java:670)",
      "at org.apache.cassandra.gms.Gossiper.applyStateLocally(Gossiper.java:624)",
      "at org.apache.cassandra.gms.Gossiper$GossipDigestAck2VerbHandler.doVerb(Gossiper.java:1016)",
      "at org.apache.cassandra.net.MessageDeliveryTask.run(MessageDeliveryTask.java:41)",
      "at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)",
      "at java.lang.Thread.run(Thread.java:636)",
      "ERROR 21:46:49,418 Fatal exception in thread Thread[GMFD:1,5,main]",
      "java.lang.RuntimeException: Bootstrap Token collision between /10.0.0.2 and /10.0.0.3 (token Token (bytes[4c617374204d6967726174696f6e])",
      "at org.apache.cassandra.locator.TokenMetadata.addBootstrapToken(TokenMetadata.java:130)",
      "at org.apache.cassandra.service.StorageService.handleStateBootstrap(StorageService.java:548)",
      "at org.apache.cassandra.service.StorageService.onChange(StorageService.java:511)",
      "at org.apache.cassandra.gms.Gossiper.doNotifications(Gossiper.java:705)",
      "at org.apache.cassandra.gms.Gossiper.applyApplicationStateLocally(Gossiper.java:670)",
      "at org.apache.cassandra.gms.Gossiper.applyStateLocally(Gossiper.java:624)",
      "at org.apache.cassandra.gms.Gossiper$GossipDigestAck2VerbHandler.doVerb(Gossiper.java:1016)",
      "at org.apache.cassandra.net.MessageDeliveryTask.run(MessageDeliveryTask.java:41)",
      "at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)",
      "at java.lang.Thread.run(Thread.java:636)"
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "Based on the stack trace, the exceptions occurs in addBootstrapToken() as follows:",
      "public voidaddBootstrapToken(Token token, InetAddress endpoint)",
      "{",
      "asserttoken !=null;",
      "assertendpoint !=null;",
      "lock.writeLock().lock();",
      "try",
      "{",
      "InetAddress oldEndpoint;",
      "oldEndpoint =bootstrapTokens.get(token);",
      "if(oldEndpoint !=null&& !oldEndpoint.equals(endpoint))",
      "throw newRuntimeException(\"Bootstrap Token collision between \"+ oldEndpoint +\" and \"+ endpoint +\" (token \"+ token);",
      "",
      "oldEndpoint =tokenToEndpointMap.get(token);",
      "if(oldEndpoint !=null&& !oldEndpoint.equals(endpoint))",
      "throw newRuntimeException(\"Bootstrap Token collision between \"+ oldEndpoint +\" and \"+ endpoint +\" (token \"+ token);",
      "",
      "bootstrapTokens.inverse().remove(endpoint);",
      "bootstrapTokens.put(token, endpoint);",
      "}",
      "finally",
      "{",
      "lock.writeLock().unlock();",
      "}",
      "}",
      "Combining the stack trace and the source code, we know that the two parameters passed into addBootstrapToken() come from the Gossip message which are sent by the newly started nodes.",
      "public voidonChange(InetAddressendpoint, String apStateName, ApplicationStateapState)",
      "{",
      "if(!MOVE_STATE.equals(apStateName))",
      "return;",
      "",
      "StringapStateValue= apState.getValue();",
      "intindex = apStateValue.indexOf(Delimiter);",
      "assert(index != -1);",
      "",
      "String moveName = apStateValue.substring(0, index);",
      "StringmoveValue=apStateValue.substring(index+1);",
      "",
      "if(moveName.equals(STATE_BOOTSTRAPPING))",
      "handleStateBootstrap(endpoint,moveValue);",
      "else if(moveName.equals(STATE_NORMAL))",
      "handleStateNormal(endpoint, moveValue);",
      "else if(moveName.equals(STATE_LEAVING))",
      "handleStateLeaving(endpoint, moveValue);",
      "else if(moveName.equals(STATE_LEFT))",
      "handleStateLeft(endpoint, moveValue);",
      "}",
      "",
      "Since the gossip message is aboutSTATE_BOOTSTRAPPING, then the token from the newly started node during bootstrapping should be checked.",
      "StorageService.initServer() -> BootStrapper.getBootstrapToken() -> getBalancedToken() -> getBootstrapSource()",
      "staticInetAddressgetBootstrapSource(finalTokenMetadata metadata,finalMap<InetAddress, Double> load)",
      "{",
      "// sort first by number of nodes already bootstrapping into a source node's range, then by load.",
      "List<InetAddress> endpoints =newArrayList<InetAddress>(load.size());",
      "for(InetAddress endpoint : load.keySet())",
      "{",
      "if(!metadata.isMember(endpoint))",
      "continue;",
      "endpoints.add(endpoint);",
      "}",
      "",
      "if(endpoints.isEmpty())",
      "throw newRuntimeException(\"No other nodes seen! Unable to bootstrap\");",
      "Collections.sort(endpoints,newComparator<InetAddress>()",
      "{",
      "public intcompare(InetAddress ia1, InetAddress ia2)",
      "{",
      "intn1 =metadata.pendingRangeChanges(ia1);",
      "intn2 =metadata.pendingRangeChanges(ia2);",
      "if(n1 != n2)",
      "return-(n1 - n2);// more targets = _less_ priority!",
      "",
      "doubleload1 =load.get(ia1);",
      "doubleload2 =load.get(ia2);",
      "if(load1 == load2)",
      "return0;",
      "returnload1 < load2 ? -1:1;",
      "}",
      "});",
      "",
      "InetAddressmaxEndpoint=endpoints.get(endpoints.size() -1);",
      "assert!maxEndpoint.equals(FBUtilities.getLocalAddress());",
      "+if(metadata.pendingRangeChanges(maxEndpoint) >0)",
      "+throw newRuntimeException(\"Every node is a bootstrap source! Please specify an initial token manually or wait for an existing bootstrap operation to finish.\");",
      "+",
      "returnmaxEndpoint;",
      "}",
      "So when the new node bootstraps, the endpoint returned by getBootstrapSource() is not valid.",
      "",
      "/**@returnthe number of nodes bootstrapping into source's primary range */",
      "public intpendingRangeChanges(InetAddress source)",
      "{",
      "intn =0;",
      "Range sourceRange = getPrimaryRangeFor(getToken(source));",
      "for(Token token :bootstrapTokens.keySet())",
      "if(sourceRange.contains(token))",
      "n++;",
      "returnn;",
      "}"
    ]
  },
  "(3) Root Cause": {
    "p": [
      "When the new nodes bootstraps, the endpoint it obtained from getBootstrapSource() is not valid. Then this endpoint is sent to the seed node through gossip, resulted in the reported exception.",
      "The exception occurs on the seed node, but the error exists in the newly started node."
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the failure. Check the validity of endpoint in getBootstrapSource(), to expose the error earlier.",
      "Â·/src/java/org/apache/cassandra/dht/BootStrapper.java",
      "@@ -138,6 +138,9 @@ public class BootStrapper",
      "",
      "InetAddress maxEndpoint = endpoints.get(endpoints.size() - 1);",
      "assert !maxEndpoint.equals(FBUtilities.getLocalAddress());",
      "+if (metadata.pendingRangeChanges(maxEndpoint) > 0)",
      "+throw new RuntimeException(\"Every node is a bootstrap source! Please specify an initial token manually or wait for an existing bootstrap operation to finish.\");",
      "+",
      "return maxEndpoint;",
      "}",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  }
}