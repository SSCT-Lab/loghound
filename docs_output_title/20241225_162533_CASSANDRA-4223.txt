{
  "p": [
    "Cassandra-4223",
    "Non Unique Streaming session ID's"
  ],
  "(1) Log information": {
    "p": [
      "The reporter observed repair processes fail due to duplicate Streaming session ID's.",
      "on DB1 (192.168.1.9) (this node is moving) (client side)",
      "INFO [RMI TCP Connection(14)-50.28.20.137] 2012-05-04 01:40:33,878 StorageService.java (line 668) MOVING: fetching new ranges and streaming old ranges",
      "DEBUG [RMI TCP Connection(14)-50.28.20.137] 2012-05-04 01:40:33,878 StreamIn.java (line 68) Requesting from /192.168.1.7ranges (24504928094253812322316810666345578171,28356863910078205288614550619314017619]",
      "DEBUG [RMI TCP Connection(14)-50.28.20.137] 2012-05-04 01:40:33,878 StreamIn.java (line 68) Requesting from /192.168.1.7 ranges (24504928094253812322316810666345578171,28356863910078205288614550619314017619]",
      "...",
      "DEBUG [Thread-28] 2012-05-04 01:40:33,928 StreamInSession.java (line 97) Adding file /var/lib/cassandra/data/FMM_Studio/PartsData-hc-1-Data.db to Stream Request queue",
      "DEBUG [Thread-28] 2012-05-04 01:40:33,938 IncomingStreamReader.java (line 77) Receiving stream",
      "DEBUG [Thread-28] 2012-05-04 01:40:33,938 IncomingStreamReader.java (line 78) Creating file for /var/lib/cassandra/data/FMM_Studio/PartsData-tmp-hc-154-Data.db with 1 estimated keys",
      "DEBUG [Thread-28] 2012-05-04 01:40:33,938 IncomingStreamReader.java (line 85) Estimated keys 1",
      "DEBUG [Thread-28] 2012-05-04 01:40:33,998 StreamInSession.java (line 105) Finished /var/lib/cassandra/data/FMM_Studio/PartsData-hc-1-Data.db sections=1 progress=305641/305641 - 100%. Sending ack to org.apache.cassandra.streaming.StreamInSession@3ea5c544",
      "INFO [Thread-28] 2012-05-04 01:40:33,998 StreamInSession.java (line 162) Finished streaming session26132848816442266from /192.168.1.7",
      "...",
      "DEBUG [Thread-29] 2012-05-04 01:40:36,468 StreamInSession.java (line 97) Adding file /var/lib/cassandra/data/OpsCenter/rollups60-hc-6-Data.db to Stream Request queue",
      "DEBUG [Thread-29] 2012-05-04 01:40:36,468 IncomingStreamReader.java (line 77) Receiving stream",
      "on DB6 (192.168.1.7) (the target of the stream request) (server side)",
      "Two streaming requests are indicated by \"Received a StreamRequestMessage\".",
      "DEBUG [StreamStage:1] 2012-05-03 21:40:33,897 StreamRequestVerbHandler.java (line 43)Received a StreamRequestMessage from /192.168.1.9",
      "...",
      "INFO [StreamStage:1] 2012-05-03 21:40:33,897 StreamOut.java (line 114) Beginning transfer to /192.168.1.9",
      "DEBUG [StreamStage:1] 2012-05-03 21:40:33,897 StreamOut.java (line 115) Ranges are (24504928094253812322316810666345578171,28356863910078205288614550619314017619]",
      "...",
      "DEBUG [StreamStage:1] 2012-05-03 21:40:33,927 StreamRequestVerbHandler.java (line 43)Received a StreamRequestMessage from /192.168.1.9",
      "...",
      "INFO [StreamStage:1] 2012-05-03 21:40:33,927 StreamOut.java (line 114) Beginning transfer to /192.168.1.9",
      "DEBUG [StreamStage:1] 2012-05-03 21:40:33,927 StreamOut.java (line 115) Ranges are (24504928094253812322316810666345578171,28356863910078205288614550619314017619]",
      "...",
      "DEBUG [Streaming:1] 2012-05-03 21:40:33,997 FileStreamTask.java (line 106) Done streaming /var/lib/cassandra/data/FMM_Studio/PartsData-hc-1-Data.db sections=1 progress=305641/305641 - 100%",
      "DEBUG [MiscStage:1]2012-05-03 21:40:33,997StreamReplyVerbHandler.java (line 47) Received StreamReply StreamReply(sessionId=26132848816442266, file='/var/lib/cassandra/data/FMM_Studio/PartsData-hc-1-Data.db', action=FILE_FINISHED)A message is received to say file FMM_Studioxxx in session 26132848816442266 has finished. This causes an exception.",
      "ERROR[MiscStage:1] 2012-05-03 21:40:34,027 AbstractCassandraDaemon.java (line 139) Fatal exception in thread Thread[MiscStage:1,5,main]",
      "java.lang.IllegalStateException: target reports current file is /var/lib/cassandra/data/FMM_Studio/PartsData-hc-1-Data.db but is null",
      "at org.apache.cassandra.streaming.StreamOutSession.validateCurrentFile(StreamOutSession.java:195)",
      "at org.apache.cassandra.streaming.StreamReplyVerbHandler.doVerb(StreamReplyVerbHandler.java:58)",
      "at org.apache.cassandra.net.MessageDeliveryTask.run(MessageDeliveryTask.java:59)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)",
      "at java.lang.Thread.run(Unknown Source)",
      "DEBUG [MiscStage:2] 2012-05-03 21:40:34,047 StreamReplyVerbHandler.java (line 47) Received StreamReply StreamReply(sessionId=26132848816442266, file='', action=SESSION_FINISHED)A session finished message for session 26132848816442266 is then received.",
      "...",
      "INFO [FlushWriter:33] 2012-05-03 21:40:35,717 Memtable.java (line 246) Writing Memtable-pdps@1010287800(7600673/192386927 serialized/live bytes, 245183 ops)",
      "INFO [FlushWriter:33] 2012-05-03 21:40:36,387 Memtable.java (line 283) Completed flushing /var/lib/cassandra/data/OpsCenter/pdps-hc-7-Data.db (7880098 bytes)",
      "...",
      "INFO [StreamStage:1] 2012-05-03 21:40:36,467 StreamOut.java (line 114) Beginning transfer to /192.168.1.9",
      "DEBUG [Streaming:1] 2012-05-03 21:40:36,467 FileStreamTask.java (line 106) Done streaming /var/lib/cassandra/data/OpsCenter/rollups7200-hc-3-Data.db sections=1 progress=69548/69548 - 100%",
      "...",
      "DEBUG [MiscStage:2] 2012-05-03 21:40:36,497 StreamReplyVerbHandler.java (line 47) Received StreamReply StreamReply(sessionId=26132848816442266, file='/var/lib/cassandra/data/OpsCenter/rollups7200-hc-3-Data.db', action=FILE_FINISHED) )A message is received to say file OpsCenter/rollupsxxx in session 26132848816442266 has finished. This causes an exception. This is the same session ID as the FMM_Studioxxx file above, but the two files are from different sessions.",
      "ERROR[MiscStage:2] 2012-05-03 21:40:36,497 AbstractCassandraDaemon.java (line 139) Fatal exception in thread Thread[MiscStage:2,5,main]",
      "java.lang.IllegalStateException: target reports current file is /var/lib/cassandra/data/OpsCenter/rollups7200-hc-3-Data.db but is null",
      "at org.apache.cassandra.streaming.StreamOutSession.validateCurrentFile(StreamOutSession.java:195)",
      "at org.apache.cassandra.streaming.StreamReplyVerbHandler.doVerb(StreamReplyVerbHandler.java:58)",
      "at org.apache.cassandra.net.MessageDeliveryTask.run(MessageDeliveryTask.java:59)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)",
      "at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)",
      "at java.lang.Thread.run(Unknown Source)"
    ]
  },
  "(2) How to figure out the root cause based on logs": {
    "p": [
      "The session id is generated on the repairing node and sent to the streaming node, so we need to check how the session id is created. Based on the fist INFO from DB1 (192.168.1.9), we can locate the code where the move operation starts.",
      "private voidmove(Token newToken)throwsIOException",
      "{...",
      "if(!rangesToStreamByTable.isEmpty() || !rangesToFetch.isEmpty())",
      "{...",
      "setMode(\"Moving: fetching new ranges and streaming old ranges\",true);",
      "...",
      "CountDownLatch fetchLatch =requestRanges(rangesToFetch);",
      "...",
      "}",
      "setToken(newToken);// setting new token as we have everything settled",
      "if(logger_.isDebugEnabled())",
      "logger_.debug(\"Successfully moved to new token {}\", getLocalToken());",
      "}",
      "",
      "This requestRanges will finally invoke requestRanges(), and session id created in it.",
      "public static voidrequestRanges(InetAddress source, String tableName, Collection<ColumnFamilyStore> columnFamilies, Collection<Range> ranges, Runnable callback, OperationType type)",
      "{",
      "assertranges.size() >0;",
      "",
      "if(logger.isDebugEnabled())",
      "logger.debug(\"Requesting from {} ranges {}\", source, StringUtils.join(ranges,\", \"));",
      "StreamInSession session = StreamInSession.create(source, callback);",
      "StreamRequestMessage srm =newStreamRequestMessage(FBUtilities.getBroadcastAddress(),",
      "ranges,tableName,columnFamilies,session.getSessionId(),type);",
      "Message message = srm.getMessage(Gossiper.instance.getVersion(source));",
      "MessagingService.instance().sendOneWay(message, source);",
      "}",
      "",
      "public staticStreamInSessioncreate(InetAddress host, Runnable callback)",
      "{",
      "Pair<InetAddress, Long> context =newPair<InetAddress, Long>(host,System.nanoTime());",
      "StreamInSession session =newStreamInSession(context, callback);",
      "sessions.put(context, session);",
      "returnsession;",
      "}",
      "It is very likely that System.nanoTime() used for the session ID behaves unexpectedly.",
      "The documentation of System.nanoTime() says that “This method provides nanosecond precision, but not necessarily nanosecond accuracy. No guarantees are made about how frequently values change.”",
      "public staticStreamOutSessioncreate(String table, InetAddress host,longsessionId, Runnable callback)",
      "{",
      "Pair<InetAddress, Long> context =newPair<InetAddress, Long>(host, sessionId);",
      "StreamOutSession session =newStreamOutSession(table, context, callback);",
      "streams.put(context, session);",
      "returnsession;",
      "}"
    ]
  },
  "(3) Root Cause": {
    "p": [
      "When node A initiates streaming to node B with StreamIn.requestRanges, it creates StreamInSession with pair of id, say, <B, 1> and sends request with session id 1.",
      "Node B receives request and creates StreamOutSession from sender's ip and received session id 1, ends up having StreamOutSession of id <A, 1>.",
      "A B",
      "StreamInSession<B, 1> --(session ID of 1 from A)--> StreamOutSession<A, 1>",
      "<-(session ID of 1 from B)---",
      "The problem is when A creates a <B, 1> Session in StreamIn, while B simultaneously creates a <B, 1> for an unrelated StreamOut.transferRanges (move or unbootstrap).",
      "“The streaming source replaced the first session with the second which resulted in both sessions failing when the first FILE_COMPLETE message was received.”"
    ]
  },
  "(4) Fixing Method": {
    "p": [
      "Fixing the error. Some of the fixed methods are on the stack trace.",
      "Make the session id [source_flag + local_int_counter]. Source flag is:",
      "·0 for a StreamInSession generated to request data.",
      "·1 for a StreamOutSession generated to transfer/push data.",
      "·A StreamOutSession created in response to a stream request (still) uses the sessionID generated remotely.",
      "It is actuallysourceof data we are requesting.",
      "One node may now have multiple stream out sessions to the same ip with the same session id:",
      "IP | source_flag | session id",
      "1.1.1.1 | 0 (started remotely) | 6",
      "1.1.1.1 | 1 (started locally) | 6",
      "· /src/java/org/apache/cassandra/streaming/StreamHeader.java",
      "@@ -33,6 +33,11 @@ public class StreamHeader",
      "{",
      "private static IVersionedSerializer<StreamHeader> serializer;",
      "",
      "+ // Streaming sessionId flags, used to avoid duplicate session id's between nodes.",
      "+ // See StreamInSession and StreamOutSession",
      "+ public static final int STREAM_IN_SOURCE_FLAG = 0;",
      "+ public static final int STREAM_OUT_SOURCE_FLAG = 1;",
      "+",
      "static",
      "{",
      "serializer = new StreamHeaderSerializer();",
      "· /src/java/org/apache/cassandra/streaming/StreamInSession.java",
      "@@ -22,6 +22,7 @@ import java.io.IOException;",
      "import java.net.InetAddress;",
      "import java.util.*;",
      "import java.util.concurrent.ConcurrentMap;",
      "+import java.util.concurrent.atomic.AtomicInteger;",
      "",
      "import org.apache.cassandra.db.ColumnFamilyStore;",
      "import org.apache.cassandra.db.Table;",
      "@@ -50,15 +51,38 @@ public class StreamInSession",
      "private final List<SSTableReader> readers = new ArrayList<SSTableReader>();",
      "private PendingFile current;",
      "",
      "+ private final static AtomicInteger sessionIdCounter = new AtomicInteger(0);",
      "+",
      "private StreamInSession(Pair<InetAddress, Long> context, Runnable callback)",
      "{",
      "this.context = context;",
      "this.callback = callback;",
      "}",
      "",
      "+ /**",
      "+ * The next session id is a combination of a local integer counter and a flag used to avoid collisions",
      "+ * between session id's generated on different machines. Nodes can may have StreamOutSessions with the",
      "+ * following contexts:",
      "+ *",
      "+ * <1.1.1.1, (stream_in_flag, 6)>",
      "+ * <1.1.1.1, (stream_out_flag, 6)>",
      "+ *",
      "+ * The first is an out stream created in response to a request from node 1.1.1.1. The id (6) was created by",
      "+ * the requesting node. The second is an out stream created by this node to push to 1.1.1.1. The id (6) was",
      "+ * created by this node.",
      "+ *",
      "+ * Note: The StreamInSession results in a StreamOutSession on the target that uses the StreamInSession sessionId.",
      "+ *",
      "+ * @return next StreamInSession sessionId",
      "+ */",
      "+ private static long nextSessionId()",
      "+ {",
      "+ return (((long)StreamHeader.STREAM_IN_SOURCE_FLAG << 32) + sessionIdCounter.incrementAndGet());",
      "+ }",
      "+",
      "public static StreamInSession create(InetAddress host, Runnable callback)",
      "{",
      "- Pair<InetAddress, Long> context = new Pair<InetAddress, Long>(host, System.nanoTime());",
      "+ Pair<InetAddress, Long> context = new Pair<InetAddress, Long>(host, nextSessionId());",
      "StreamInSession session = new StreamInSession(context, callback);",
      "sessions.put(context, session);",
      "return session;",
      "@@ -168,6 +192,11 @@ public class StreamInSession",
      "}",
      "}",
      "",
      "+ public int getSourceFlag()",
      "+ {",
      "+ return (int)(context.right >> 32);",
      "+ }",
      "+",
      "public long getSessionId()",
      "{",
      "return context.right;",
      "· /src/java/org/apache/cassandra/streaming/StreamOutSession.java",
      "import java.util.concurrent.atomic.AtomicBoolean;",
      "+import java.util.concurrent.atomic.AtomicInteger;",
      "",
      "import org.apache.commons.lang.StringUtils;",
      "import org.slf4j.Logger;",
      "@@ -43,10 +44,29 @@ public class StreamOutSession implements IEndpointStateChangeSubscriber, IFailur",
      "",
      "// one host may have multiple stream sessions.",
      "private static final ConcurrentMap<Pair<InetAddress, Long>, StreamOutSession> streams = new NonBlockingHashMap<Pair<InetAddress, Long>, StreamOutSession>();",
      "+ private final static AtomicInteger sessionIdCounter = new AtomicInteger(0);",
      "+",
      "+ /**",
      "+ * The next session id is a combination of a local integer counter and a flag used to avoid collisions",
      "+ * between session id's generated on different machines. Nodes can may have StreamOutSessions with the",
      "+ * following contexts:",
      "+ *",
      "+ * <1.1.1.1, (stream_in_flag, 6)>",
      "+ * <1.1.1.1, (stream_out_flag, 6)>",
      "+ *",
      "+ * The first is an out stream created in response to a request from node 1.1.1.1. The id (6) was created by",
      "+ * the requesting node. The second is an out stream created by this node to push to 1.1.1.1. The id (6) was",
      "+ * created by this node.",
      "+ * @return next StreamOutSession sessionId",
      "+ */",
      "+ private static long nextSessionId()",
      "+ {",
      "+ return (((long)StreamHeader.STREAM_OUT_SOURCE_FLAG << 32) + sessionIdCounter.incrementAndGet());",
      "+ }",
      "",
      "public static StreamOutSession create(String table, InetAddress host, Runnable callback)",
      "{",
      "- return create(table, host, System.nanoTime(), callback);",
      "+ return create(table, host, nextSessionId(), callback);",
      "}",
      "",
      "public static StreamOutSession create(String table, InetAddress host, long sessionId)",
      "@@ -84,6 +104,11 @@ public class StreamOutSession implements IEndpointStateChangeSubscriber, IFailur",
      "FailureDetector.instance.registerFailureDetectionEventListener(this);",
      "}",
      "",
      "+ public int getSourceFlag()",
      "+ {",
      "+ return (int)(context.right >> 32);",
      "+ }",
      "+",
      "public InetAddress getHost()",
      "{",
      "return context.left;",
      "@@ -138,7 +163,7 @@ public class StreamOutSession implements IEndpointStateChangeSubscriber, IFailur",
      "// time, if the endpoint die at the exact wrong time for instance.",
      "if (!isClosed.compareAndSet(false, true))",
      "{",
      "- logger.debug(\"StreamOutSession {} already closed\", getSessionId());",
      "+ logger.debug(\"StreamOutSession {} to {} already closed\", getSessionId(), getHost());",
      "return;",
      "}",
      "Add more information to the log message.",
      "",
      "",
      "",
      ""
    ]
  }
}